---
title:08-再谈微服务
time: 2020年7月28日

---

[toc]

## 一、微服务的概念

### 1.1 概述

微服务架构是一种架构概念，旨在通过将功能分解到各个离散的服务中以实现对解决方案的解耦。它的主要作用是将功能分解到离散的各个服务当中，从而降低系统的耦合性，并提供更加灵活的服务支持。

### 1.2 概念

把一个大型的单个应用程序和服务拆分为数个甚至数十个的支持微服务，它可扩展单个组件而不是整个的应用程序堆栈，从而满足服务等级协议。

### 1.3 定义

围绕业务领域组件来创建应用，这些应用可独立地进行开发、管理和迭代。在分散的组件中使用云架构和平台式部署、管理和服务功能，使产品交付变得更加简单。

### 1.4 本质

用一些功能比较明确、业务比较精练的服务去解决更大、更实际的问题。

> **PS：** 微服务这个概念是 2012 年出现的，作为加快 Web 和移动应用程序开发进程的一种方法，2014 年开始受到各方的关注，同年为微服务的元年；



## 二、传统架构与微服务架构的区别

### 2.1 系统架构需要遵循的三个标准

- 提高敏捷性：及时响应业务需求，促进企业发展
- 提升用户体验：提升用户体验，减少用户流失
- 降低成本：降低增加产品、客户或业务方案的成本

### 2.2 传统的开发模式

先来看看传统的 WEB 开发方式，通过对比比较容易理解什么是 **微服务架构**。和 **微服务** 相对应的，这种方式一般被称为 **单体式开发（Monolithic）**。

既所有的功能打包在一个 WAR 包里，基本没有外部依赖（除了容器），部署在一个 JavaEE 容器（Tomcat，JBoss，WebLogic）里，包含了 DO/DAO，Service，UI 等所有逻辑。

![img](https://funtl.com/assets/Lusifer2018052805390001.png)

#### 2.2.1 优点

- 开发简单，集中式管理
- 基本不会重复开发
- 功能都在本地，没有分布式的管理和调用消耗

#### 2.2.2 缺点

- 效率低：开发都在同一个项目改代码，相互等待，冲突不断
- 维护难：代码功功能耦合在一起，新人不知道何从下手
- 不灵活：构建时间长，任何小修改都要重构整个项目，耗时
- 稳定性差：一个微小的问题，都可能导致整个应用挂掉
- 扩展性不够：无法满足高并发下的业务需求



### 2.3 微服务架构

有效的拆分应用，实现敏捷开发和部署

![img](https://funtl.com/assets/Lusifer2018052805390002.png)

#### 2.3.2 开发和交付中的伸缩立方

![img](https://funtl.com/assets/0714fcab4f6d5951014e5613657c8289.png)

**X轴：** 运行多个负载均衡器之后的运行实例 **Y轴：** 将应用进一步分解为微服务（分库） **Z轴：** 大数据量时，将服务分区（分表）



### 2.4 微服务的特征

#### 2.4.1 官方定义

- 一系列的独立的服务共同组成系统
- 单独部署，跑在自己的进程中
- 每个服务为独立的业务开发
- 分布式管理
- 非常强调隔离

#### 2.4.2 大概的标准

- 分布式服务组成的系统
- 按照业务，而不是技术来划分组织
- 做有生命的产品而不是项目
- 强服务个体和弱通信（ Smart endpoints and dumb pipes ）
- 自动化运维（ DevOps ）
- 高度容错性
- 快速演化和迭代



> AOP 思想将主业务与交叉业务分离，实现解耦。

## 三、微服务的实践

### 3.1 概述

（多看看）

***三大指标（高可用、高并能、高并发）、四大问题***

微服务架构，是一种架构思想，实际开发采用的是分布式系统开发。架构就是为了解决耦合度问题。在分布式系统开发中一定会遇到四种问题：

1. 这么多服务，客户端如何请求；
2. 这么多服务，服务之间如何通讯；
3. 这么多服务，如何实现？
4. 这么多服务，服务挂了怎么办？



### 3.2 客户端如何访问

假设现在后台有 N 个服务，那么前台就需要记住这 N 个服务的地址（IP 地址以及端口）。当部分服务**下线**、**更新**、**升级**时，前台就需要改变对应的地址，也就是说，前台需要重新部署。当前台是移动应用的时候，业务变化得特别快，这个矛盾更加尖锐、。

另外，N 个小服务的调用也是一个不小的网络开销。还有一般微服务在系统内部，通常是无状态的，用户登录信息和权限管理最好有一个统一的地方维护管理（OAuth）。

所以，一般在后台 N 个服务和 UI 之间一般会一个代理或者叫 `API Gateway`，他的作用包括：

- 提供统一服务入口，让微服务对前台透明
- 聚合后台的服务，节省流量，提升性能
- 提供安全，过滤，流控等API管理功能

> 添加的『网关』应用了『面向切面』编程思想。

其实这个 `API Gateway` 可以有很多广义的实现办法，可以是一个软硬一体的盒子，也可以是一个简单的 MVC 框架，甚至是一个 `Node.js` 的服务端。他们最重要的作用是为前台（通常是移动应用）提供后台服务的聚合，提供一个统一的服务出口，解除他们之间的耦合，不过 `API Gateway` 也有可能成为 **单点故障**点或者性能的瓶颈。

![img](https://funtl.com/assets/Lusifer2018052805390003.png)



### 3.3 服务之间如何通信

所有的微服务都是独立的 Java 进程跑在独立的虚拟机上，所以服务间的通信就是 IPC（Inter Process Communication），已经有很多成熟的方案。现在基本最通用的有两种方式：

1. 同步调用；
2. 异步调用；

#### 3.3.1 同步调用

- REST（JAX-RS，Spring Boot）
- RPC（Thrift, Dubbo）

同步调用比较简单，一致性强，但是容易出调用问题，性能体验上也会差些，特别是调用层次多的时候。一般 REST 基于 HTTP，更容易实现，更容易被接受，服务端实现技术也更灵活些，各个语言都能支持，同时能跨客户端，对客户端没有特殊的要求，只要封装了 HTTP 的 SDK 就能调用，所以相对使用的广一些。

RPC 也有自己的优点，传输协议更高效，安全更可控，特别在一个公司内部，如果有统一个的开发规范和统一的服务框架时，他的开发效率优势更明显些。就看各自的技术积累实际条件，自己的选择了。

> 一般来说，当需要对外提供服务的时候，会使用 REST 方式；而在局域网内部通信的话，则使用 RPC。简称：**对外 REST， 对内 RPC**。

#### 3.3.2 异步调用

异步调用一般采用『消息队列』作为中间件实现。

常见的实现方式有：

- Kafka
- Notify
- MessageQueue



异步消息的方式在分布式系统中有特别广泛的应用，他既能减低调用服务之间的耦合，又能成为调用之间的缓冲，确保消息积压不会冲垮被调用方，同时能保证调用方的服务体验，继续干自己该干的活，不至于被后台性能拖慢。不过需要付出的代价是一致性的减弱，需要接受数据 **最终一致性**；还有就是后台服务一般要实现 **幂等性**，因为消息送出于性能的考虑一般会有重复（保证消息的被收到且仅收到一次对性能是很大的考验）；最后就是必须引入一个独立的 `Broker`。

![img](https://funtl.com/assets/Lusifer2018052805390004.png)

> 有业务的叫做 Bean，没有业务的叫做 POJO。



### 3.4 这么多服务，如何实现

在微服务架构中，一般每一个服务都是有多个拷贝，来做负载均衡。一个服务随时可能下线，也可能应对临时访问压力增加新的服务节点。服务之间如何相互感知？服务如何管理？

这就是服务发现的问题了。一般有两类做法，也各有优缺点。基本都是通过 Zookeeper 等类似技术做服务注册信息的分布式管理。当服务上线时，服务提供者将自己的服务信息注册到 ZK（或类似框架），并通过心跳维持长链接，实时更新链接信息。服务调用者通过 ZK 寻址，根据可定制算法，找到一个服务，还可以将服务信息缓存在本地以提高性能。当服务下线时，ZK 会发通知给服务客户端。

#### 3.4.1 基于客户端的服务注册与发现

优点是架构简单，扩展灵活，只对服务注册器依赖。缺点是客户端要维护所有调用服务的地址，有技术难度，一般大公司都有成熟的内部框架支持，比如 Dubbo。

![img](https://funtl.com/assets/Lusifer2018052805390005.png)

#### 3.4.2 基于服务器的服务注册与发现

优点是简单，所有服务对于前台调用方透明，一般在小公司在云服务上部署的应用采用的比较多。

![img](https://funtl.com/assets/Lusifer2018052805390006.png)

## 四、微服务架构设计模式

参考地址：[微服务架构设计模式](https://funtl.com/zh/micro-service-about/%E5%86%8D%E8%B0%88%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F)。